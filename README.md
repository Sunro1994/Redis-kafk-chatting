# [1. 설계하기] 채팅 기능 설계 기술 소개

## 1. 웹소켓이란?

양방향 통신기법으로 실시간성을 보장하는 방식입니다. 채팅, 게임, 가상화폐 거래소에서 활용됩니다. HTTP 통신과의 차이점으로는 HTTP는 클라이언트가 서버에 요청하는 것이고, 웹소켓은 서버와 클라이언트간의 양방향 요청이 가능합니다.

사실 HTTP에도 실시간성을 보장하는 기법이 존재한다.

- **Polling**: 클라이언트(브라우저)가 주기적으로 서버에게 이벤트가 발생했는지 확인하는 방식입니다. 특정 시간 간격으로 클라이언트가 새로고침한다고 생각하면 이해하기 쉬울 것 같습니다. 단, 주기적으로 서버에게 이벤트 발생 여부를 확인하는 방식이라, 불필요한 네트워크 트래픽이 발생할 수 있습니다.
- **Long Polling**: 위의 폴링 방식의 실시간성을 보완한 기법입니다. 기존 폴링에서는 브라우저의 요청에 따라 '항상' 응답을 담아서 보내줬다면, 롱 폴링에서는 '이벤트'가 발생할 때만 '응답'을 담아서 보냅니다.

위 방법들은 Connection의 연결, 해제가 반복되어 효율이 많이 떨어집니다. 하지만, 뉴스와 메일같이 변경사항의 빈도가 자주 발생하지 않는 경우에서는 위의 방식이 웹소켓보다 효과적일 수 있습니다.

HTTP 방식에서도 웹소켓과 비슷한 이벤트 전송 기법이 있습니다.

- **Server-sent Events (SSE)**: 클라이언트의 요청은 없이 서버에서 클라이언트에게 단방향으로 이벤트를 전송하는 기법입니다. 클라이언트는 서버에게 특정 이벤트를 구독 요청을 전송하고, 서버는 해당 이벤트가 발생하면 해당 이벤트를 전송합니다. 하지만 클라이언트에서 서버로는 데이터를 보낼 수 없어, 채팅에서는 적합하지 않습니다.

### 웹소켓의 특징

1. **Stateful Protocol**: 최초 접속에서만 일반적인 HTTP 프로토콜로 HandShaking 과정을 수행하여 소켓을 열고난 후, HTTP 기반의 Websocket 프로토콜 (ws)로 운영됩니다. Https 일 경우 (wss)로 운영됩니다.
2. **데이터 효율성**: HTTP에 비해 웹소켓이 보내야 하는 메시지, 데이터양이 훨씬 적습니다. 웹 소켓은 수 byte로 압축이 가능하여 매우 짧은 대기시간과 높은 볼륨이 필요한 경우 활용하면 좋습니다.
3. **부하 발생 가능성**: 서버와 클라이언트는 항상 연결을 유지해야 하기 때문에 오히려 부하가 발생할 수 있습니다. 트래픽 양이 많은 서버 같은 경우 CPU에 큰 부담이 될 수 있습니다.

## 2. STOMP? (Simple/Stream Text Oriented Message Protocol)

웹소켓으로 구현한 채팅 서비스 기록들을 보면 반드시 따라오는 게 STOMP!
웹 소켓은 기본적으로 *** 텍스트 *** 와 *** 바이너리 타입의 메시지***를 양방향으로 주고받는 프로토콜입니다.
STOMP는 이 메시지의 타입을 정의하는 텍스트 기반 메시징 프로토콜입니다.

### STOMP의 장점

1. **pub/sub 구조**: 추후 카프카 같이 외부 Messaging Queue를 활용해 고도화시킬 때 편리합니다.
2. **헤더 설정 가능**: 통신 메시지의 헤더에 값을 세팅할 수 있어, 인증처리 (Spring Security)의 도입도 가능합니다.

### pub/sub 구조

메시지를 공급하는 주체와 소비하는 주체를 분리하여 제공하는 메시징 방법입니다.

- 채팅방을 생성한다 ▶️ pub/sub 구현을 위한 Topic이 하나 생성된다.
- 채팅방에 입장한다 ▶️ Topic을 구독 (sub) 한다.
- 나는 채팅에 메시지를 보낸다 ▶️ 해당 Topic으로 메시지를 발행 (pub) 한다.
- 상대방은 나의 채팅을 받는다 ▶️ 구독한(sub) Topic에 발행된 메시지를 받는다.

### Websocket/STOMP 채팅 구현시 단점

채팅을 웹소켓과 STOMP 방식으로만 구현할 경우, pub/sub가 발생한 서버 내에서만 메시지를 주고 받을 수 있습니다. 즉 다른 서버로 접속한 클라이언트는 해당 채팅방을 볼 수 없게 됩니다. 여러 서버에서 접근이 가능하게 하려면, 카프카와 레디스 같은 외부 메시지 큐를 활용하면 됩니다.  **스케일 아웃을 쉽게 적용할 수 있도록** 메시지 큐를 활용하여 채팅 시스템을 고도화하는 것이 목표

## 3. Redis pub/sub란?

Redis는 key-value 구조의 데이터를 저장할 수 있는 오픈 소스 기반의 비 관계형 데이터베이스이자 *** 인 메모리 구조 데이터베이스*** 입니다. 데이터베이스, 캐시, 메시지 브로커로 사용될 수 있습니다. Redis pub/sub는 분산시스템의 다양한 구성 요소 간에 실시간 메시지 교환이 가능하게 하는 메시징 패턴입니다.

### Redis pub/sub의 특징

- 같은 Topic을 구독한 모든 sub에게 메시지를 전달하는 기능을 제공합니다.
- 속도가 굉장히 빨라 초당 수천만 개의 메시지를 전달할 수 있습니다.
- 스프링에서도 매우 간단하게 코드로 구현할 수 있습니다.

### 단점

1MB를 초과하는 메시지의 경우 상당한 지연시간이 발생할 수 있습니다.또한 발행(pub)된 메시지를 저장하지 않고 바로 삭제합니다. 그렇기 때문에 메시지 저장용으로는 Mongo DB를 활용하는 것이 좋음.

### 카프카 vs Redis

pub/sub 기능을 제공하는 외부 메시지 큐로 대표적으로는 카프카도 있지만,카프카는 MSA구조이기때문에 프리티어로는 구현이 어려워서 패스
## 4. 채팅시 DB는? - NoSQL: Mongo DB

채팅은 실시간으로 일어나고 다른 API들보다 훨씬 많이 읽고 쓰는 작업이 발생합니다. 그렇지만 '수정' 작업이 잘 일어나지 않습니다.


### NoSQL이란?

비관계형 데이터베이스로, 구조화되지 않는 데이터를 저장할 수 있습니다.

1. **확장성**: SQL은 수직 확장 접근 방식으로, 서버에 더 많은 기능을 추가하여 확장합니다. NoSQL은 수평 확장 접근 방식으로, 더 많은 서버를 추가하여 확장합니다.
2. **데이터 유연성**: SQL은 ACID(원자성, 일관성, 고립성, 지속성) 규칙을 따라 데이터를 안전하게 저장되고 트랜잭션이 일관되게 처리되지만, NoSQL은 ACID 규칙을 따르지 않아 데이터가 항상 안전하게 저장되지는 않습니다. 하지만 그만큼 데이터를 유연하게 저장하고 처리할 수 있습니다.
3. **비관계형**: NoSQL은 비 관계형이기 때문에 조인이 많이 필요한 데이터인 경우 적합하지 않습니다. 하지만 SQL에 비해 스키마가 없고 데이터는 애플리케이션이 필요로 하는 형식으로 저장되기 때문에, 많은 양의 데이터를 보다 빠르게 읽을 수 있습니다. 실제로 미국의 메신저 기업 스냅챗 또한 NoSQL 데이터베이스를 활용하고 있습니다.

채팅방 정보만 MySQL DB에 저장, 기록은 NoSQL인 MongoDB

### Mongo DB의 장점

1. **JSON 타입 저장**: 데이터 형식이 바뀌어도 따로 설정할 것이 없어 매우 편리합니다. MySQL인 경우 데이터의 형식이 다르면 테이블을 초기화하거나 수정해야 했지만, MongoDB는 그런 작업이 없어도 됩니다.
2. **Mongo DB Compass**: 데이터를 쉽게 확인할 수 있습니다.
3. **Spring boot와의 연동성**: 설정만 해주면 간편하게 사용할 수 있습니다.
